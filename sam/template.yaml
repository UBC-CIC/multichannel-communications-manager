# This is the SAM template that represents the architecture of your serverless application
# https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-template-basics.html

# The AWSTemplateFormatVersion identifies the capabilities of the template
# https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/format-version-structure.html
AWSTemplateFormatVersion: '2010-09-09'
Description: >-
  Multichannel Communications Manager SAM deployment

# Transform section specifies one or more macros that AWS CloudFormation uses to process your template
# https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/transform-section-structure.html
Transform:
  AWS::Serverless-2016-10-31

Parameters:
  ProjectName:
    Type: String
    Default: newsletterManager
    Description: A name to identify the project
    AllowedPattern: '[a-zA-Z][a-zA-Z0-9]*'
    MinLength: 1
    MaxLength: 32
    ConstraintDescription: must begin with a letter, and only contain alphanumeric characters (1-32 characters)
  EnvironmentName:
    Type: String
    Default: dev
    Description: A name to identify the environment (ex. dev, prod, test)
  LinkToHostingDomain:
    Description: Link to the user portal
    Type: String
  DBName:
    Default: sys
    Description: The database name
    Type: String
    MinLength: 1
    MaxLength: 64
    AllowedPattern: '[a-zA-Z][a-zA-Z0-9]*'
    ConstraintDescription: must begin with a letter and contain only alphanumeric characters.
  # DBUser:
  #   Default: admin
  #   Description: The database admin account username
  #   Type: String
  #   MinLength: 1
  #   MaxLength: 16
  #   AllowedPattern: '[a-zA-Z][a-zA-Z0-9]*'
  #   ConstraintDescription: must begin with a letter and contain only alphanumeric characters.
  # DBPassword:
  #   Description: The database admin account password
  #   Type: String
  #   MinLength: 1
  #   MaxLength: 41
  #   AllowedPattern: '[a-zA-Z0-9]+'
  #   ConstraintDescription: must contain only alphanumeric characters.
  DBInstanceClass:
    Description: The database instance type
    Type: String
    Default: db.t4g.large
    AllowedValues: [db.t2.small, db.t2.medium, db.t3.small, db.t3.medium, db.t4g.medium, db.t4g.large, db.r4.large, db.r4.xlarge, db.r4.2xlarge, db.r4.4xlarge, db.r4.8xlarge, db.r4.16xlarge, db.r5.large, db.r5.xlarge, db.r5.2xlarge, db.r5.4xlarge, db.r5.8xlarge, db.r5.12xlarge, db.r5.16xlarge, db.r6g.large, db.r6g.xlarge, db.r6g.2xlarge, db.r6g.4xlarge, db.r6g.8xlarge, db.r6g.12xlarge, db.r6g.16xlarge]
  DBEngineVersion:
    Description: The version of Aurora MySQL for the database
    Type: String
    Default: 5.7.mysql_aurora.2.09.2
    AllowedValues: [5.7.mysql_aurora.2.07.0, 5.7.mysql_aurora.2.07.1, 5.7.mysql_aurora.2.07.1, 5.7.mysql_aurora.2.07.2, 5.7.mysql_aurora.2.07.3, 5.7.mysql_aurora.2.07.4, 5.7.mysql_aurora.2.07.5, 5.7.mysql_aurora.2.07.6, 5.7.mysql_aurora.2.07.7, 5.7.mysql_aurora.2.08.0, 5.7.mysql_aurora.2.08.1, 5.7.mysql_aurora.2.08.2, 5.7.mysql_aurora.2.08.3, 5.7.mysql_aurora.2.08.4, 5.7.mysql_aurora.2.09.0, 5.7.mysql_aurora.2.09.1, 5.7.mysql_aurora.2.09.2, 5.7.mysql_aurora.2.09.3, 5.7.mysql_aurora.2.10.0, 5.7.mysql_aurora.2.10.1, 5.7.mysql_aurora.2.10.2, 8.0.mysql_aurora.3.01.0, 8.0.mysql_aurora.3.01.1, 8.0.mysql_aurora.3.02.0]
  DeletionProtection:
    Description: When deletion proteciton is enabled, when you request the deletion of a database instance in the AWS Console you are blocked and may not continue without first modifying the instance and disabling deletion protection (recommended for production)
    Type: String
    Default: True
  EncryptDatabase:
    Description: Enable encryption of the database
    Type: String
    Default: True
  SenderEmail:
    Type: String
    Description: The email address from which end uers will receive emails
  OrganizationName:
    Type: String
    Description: The name for the organization that will appear in the subscription message


Resources:
  GraphQLApiIdParameter:
      Type: AWS::SSM::Parameter
      Properties: 
        Name: "GraphQLApiIdParameter"
        Type: String 
        Value: "{{resolve:ssm:GraphqlApiId:1}}"
        Description: Communication Manager GraphQL Api Id

  IGW:
    Type: AWS::EC2::InternetGateway
    Properties: 
      Tags:
        - Key: "Project"
          Value: !Ref 'ProjectName'
        - Key: "EnvironmentName"
          Value: !Ref 'EnvironmentName'

  VPC:
    Type: AWS::EC2::VPC
    Properties: 
      CidrBlock: 10.0.0.0/16
      EnableDnsHostnames: true
      EnableDnsSupport: true
      InstanceTenancy: default
      Tags:
        - Key: "Project"
          Value: !Ref 'ProjectName'
        - Key: "EnvironmentName"
          Value: !Ref 'EnvironmentName'
        - Key: "Name"
          Value: !Sub ${ProjectName} VPC

  IGWAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    DependsOn:
    - IGW
    - VPC
    Properties:
      InternetGatewayId: !Ref IGW
      VpcId: !Ref VPC
  
  PublicSubnet1:
    Type: AWS::EC2::Subnet
    DependsOn:
    - VPC
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [ 0, !GetAZs '' ]
      CidrBlock: 10.0.0.0/24
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: !Sub ${EnvironmentName} Public Subnet (AZ1)
        - Key: "Project"
          Value: !Ref 'ProjectName'
        - Key: "EnvironmentName"
          Value: !Ref 'EnvironmentName'

  PublicSubnet2:
    Type: AWS::EC2::Subnet
    DependsOn:
    - VPC
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [ 1, !GetAZs  '' ]
      CidrBlock: 10.0.1.0/24
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: !Sub ${EnvironmentName} Public Subnet (AZ2)
        - Key: "Project"
          Value: !Ref 'ProjectName'
        - Key: "EnvironmentName"
          Value: !Ref 'EnvironmentName'

  PrivateSubnet1:
    Type: AWS::EC2::Subnet
    DependsOn:
    - VPC
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [ 0, !GetAZs  '' ]
      CidrBlock: 10.0.2.0/24
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: !Sub ${EnvironmentName} Private Subnet (AZ1)
        - Key: "Project"
          Value: !Ref 'ProjectName'
        - Key: "EnvironmentName"
          Value: !Ref 'EnvironmentName'


  PrivateSubnet2:
    Type: AWS::EC2::Subnet
    DependsOn:
    - VPC
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [ 1, !GetAZs  '' ]
      CidrBlock: 10.0.3.0/24
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: !Sub ${EnvironmentName} Private Subnet (AZ2)
        - Key: "Project"
          Value: !Ref 'ProjectName'
        - Key: "EnvironmentName"
          Value: !Ref 'EnvironmentName'

  # PrivateSubnet3:
  #   Type: AWS::EC2::Subnet
  #   Properties:
  #     VpcId: !Ref VPC
  #     AvailabilityZone: !Select [ 0, !GetAZs  '' ]
  #     CidrBlock: 10.0.4.0/24
  #     MapPublicIpOnLaunch: false

  # PrivateSubnet4:
  #   Type: AWS::EC2::Subnet
  #   Properties:
  #     VpcId: !Ref VPC
  #     AvailabilityZone: !Select [ 1, !GetAZs  '' ]
  #     CidrBlock: 10.0.5.0/24
  #     MapPublicIpOnLaunch: false
  

  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    DependsOn:
    - VPC
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub ${EnvironmentName} Public Routes
        - Key: "Project"
          Value: !Ref 'ProjectName'
        - Key: "EnvironmentName"
          Value: !Ref 'EnvironmentName'

  PublicRoute1:
    Type: AWS::EC2::Route
    DependsOn: 
      - IGWAttachment
      - PublicRouteTable
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref IGW

  PublicSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet1
      RouteTableId: !Ref PublicRouteTable

  PublicSubnet2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet2
      RouteTableId: !Ref PublicRouteTable


  PrivateRouteTable:
    Type: AWS::EC2::RouteTable
    DependsOn:
    - VPC
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub ${EnvironmentName} Private Routes
        - Key: "Project"
          Value: !Ref 'ProjectName'
        - Key: "EnvironmentName"
          Value: !Ref 'EnvironmentName'

  PrivateSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PrivateSubnet1
      RouteTableId: !Ref PrivateRouteTable

  PrivateSubnet2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PrivateSubnet2
      RouteTableId: !Ref PrivateRouteTable

  ClosedSG:
    Type: AWS::EC2::SecurityGroup
    Properties: 
      GroupDescription: A security group that allows no traffic in, but all traffic out from port 443, 80, and 3306
      # GroupName: closed-security-group
      SecurityGroupEgress: 
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
          Description: allows all traffic out from port 443
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
          Description: allows all traffic out from port 80
        - IpProtocol: tcp
          FromPort: 3306
          ToPort: 3306
          CidrIp: 0.0.0.0/0
          Description: allows all traffic out from port 3306
      VpcId: !Ref VPC
      Tags:
        - Key: "Project"
          Value: !Ref 'ProjectName'
        - Key: "EnvironmentName"
          Value: !Ref 'EnvironmentName'
  
  ProxySG:
    Type: AWS::EC2::SecurityGroup
    # DependsOn:
    #   - ClosedSG
    Properties: 
      GroupDescription: A security group for RDS that allows all traffic in on port 3306 from ClosedSG
      # GroupName: Proxy-security-group
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 3306
          ToPort: 3306
          SourceSecurityGroupId: !Ref ClosedSG
          Description: allows all traffic in on port 3306 from ClosedSG
      SecurityGroupEgress:
        # - IpProtocol: tcp
        #   FromPort: 3306
        #   ToPort: 3306
        #   DestinationSecurityGroupId: !Ref ClosedSG
        #   Description: allows all traffic out on port 3306 to ClosedSG
        # - IpProtocol: tcp
        #   FromPort: 3306
        #   ToPort: 3306
        #   DestinationSecurityGroupId: !Ref RdsSG
        #   Description: allows all traffic out on port 3306 to RdsSG
        - IpProtocol: tcp
          FromPort: 3306
          ToPort: 3306
          CidrIp: '10.0.0.0/16'
          Description: allows all traffic out on port 3306 to vpc



  RdsSG:
    Type: AWS::EC2::SecurityGroup
    # DependsOn:
      # - ClosedSG
      # - ProxySG
    Properties: 
      GroupDescription: A security group for RDS that allows all traffic in on port 3306 from the proxy and other vpc resources
      # GroupName: RDS-security-group
      VpcId: !Ref VPC
      SecurityGroupIngress:
        # - IpProtocol: tcp
        #   FromPort: 3306
        #   ToPort: 3306
        #   SourceSecurityGroupId: !Ref ClosedSG
        #   Description: allows all tcp traffic in on port 3306 from ClosedSG
        - IpProtocol: tcp
          FromPort: 3306
          ToPort: 3306
          SourceSecurityGroupId: !Ref ProxySG
          Description: allows all tcp traffic out on port 3306 from ProxySG
      SecurityGroupEgress:
        # - IpProtocol: tcp
        #   FromPort: 3306
        #   ToPort: 3306
        #   DestinationSecurityGroupId: !Ref ClosedSG
        #   Description: allows all tcp traffic out on port 3306 to ClosedSG
        - IpProtocol: tcp
          FromPort: 3306
          ToPort: 3306
          CidrIp: '10.0.0.0/16'
          Description: allows all traffic out on port 3306 to vpc
    

# RDS #########################################
  
  DBSubnetGrouping:
    Type: AWS::RDS::DBSubnetGroup
    Properties: 
      DBSubnetGroupDescription: Subnet group!
      DBSubnetGroupName: subnet-group-1-2
      SubnetIds: 
        - !Ref PublicSubnet1
        - !Ref PublicSubnet2

  DatabasePrivateSubnetGrouping:
    Type: AWS::RDS::DBSubnetGroup
    Properties: 
      DBSubnetGroupDescription: Subnet grouping for private subnets
      # DBSubnetGroupName: subnetgroup-private-1-2
      SubnetIds: 
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2

  DbCluster:
    Type: AWS::RDS::DBCluster
    DependsOn:
    - VPC
    - PrivateSubnet1
    - PrivateSubnet2
    - DatabasePrivateSubnetGrouping
    Properties: 
      DatabaseName: !Ref 'DBName'
      # DbClusterIdentifier: mcmDbCluster
      DBClusterParameterGroupName: !Ref RDSClusterParameterGroup
      DBSubnetGroupName: !Ref DatabasePrivateSubnetGrouping
      DeletionProtection: !Ref 'DeletionProtection'
      EnableCloudwatchLogsExports: 
        - general
        - error
      EnableHttpEndpoint: true 
      EnableIAMDatabaseAuthentication: false 
      Engine: aurora-mysql
      EngineVersion: !Ref 'DBEngineVersion'
      MasterUsername: !Sub '{{resolve:secretsmanager:${DBCredentialsSecret}::username}}'
      MasterUserPassword: !Sub '{{resolve:secretsmanager:${DBCredentialsSecret}::password}}'
      Port: 3306
      StorageEncrypted: !Ref 'EncryptDatabase' 
      SourceRegion: !Sub '${AWS::Region}'
      Tags: 
        - Key: "Project"
          Value: !Ref 'ProjectName'
        - Key: "EnvironmentName"
          Value: !Ref 'EnvironmentName'
      VpcSecurityGroupIds:  
        - !Ref RdsSG

  DBInstance:
    Type: AWS::RDS::DBInstance
    DependsOn:
    - DbCluster
    Properties: 
      DBClusterIdentifier: !Ref DbCluster
      Engine: aurora-mysql 
      DBInstanceClass: !Ref 'DBInstanceClass'
      # DBInstanceIdentifier: !Sub '${ProjectName}-${EnvironmentName}-dbinstance'
      PubliclyAccessible: false 
      # DBParameterGroupName: 
      #   Ref: RDSDBParameterGroup
      Tags: 
        - Key: "Project"
          Value: !Ref 'ProjectName'
        - Key: "EnvironmentName"
          Value: !Ref 'EnvironmentName'
      
  RDSClusterParameterGroup:
    Type: "AWS::RDS::DBClusterParameterGroup"
    Properties:
      Description: "CloudFormation Parameter Group"
      Family: aurora-mysql5.7
      Parameters:
        binlog_format: ROW

  DBCredentialsSecret:
    Type: AWS::SecretsManager::Secret
    DependsOn:
    # - DbCluster
    - IGWAttachment
    # - DBInstance
    Properties: 
      Description: Stores the credentials for the RDS instance
      Name: DBCredentials
      GenerateSecretString:
        SecretStringTemplate: !Sub '{"username":"admin","engine":"mysql","port":3306,"region":"${AWS::Region}"}'
        # !Sub '{"username":"admin","engine":"mysql","host":"${DbCluster.Endpoint.Address}","port":3306,"region":"${AWS::Region}"}'
      # SecretString: !Sub '{"username":"${DBUser}","password":"${DBPassword}","engine":"mysql","host":"${DbCluster.Endpoint.Address}","port":3306,"region":"${AWS::Region}"}'
        GenerateStringKey: "password"
        ExcludeCharacters: '"@/\'
      KmsKeyId: !GetAtt KmsKey.Arn
      Tags:
        - Key: "Project"
          Value: !Ref 'ProjectName'
        - Key: "EnvironmentName"
          Value: !Ref 'EnvironmentName'

  LambdaServiceRole:
    Type: AWS::IAM::Role
    Properties:
      # RoleName: !Sub 'LambdaFunction-ServiceRole-${AWS::Region}'    
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - 'appsync.amazonaws.com'
            Action:
              - 'sts:AssumeRole'
      Policies:
        - PolicyName: allow-lambda-access-from-appsync
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: appsync:GraphQL
                Resource: !Sub "arn:aws:appsync:${AWS::Region}:${AWS::AccountId}:apis/${GraphQLApiIdParameter.Value}"
              - Effect: Allow
                Action: lambda:InvokeAsync
                Resource: !GetAtt graphQLMySQLResolver.Arn
              - Effect: Allow
                Action: lambda:InvokeFunction
                Resource: !GetAtt graphQLMySQLResolver.Arn
  EIP:
    Type: 'AWS::EC2::EIP'
    Properties:
      Domain: vpc

  NatGateway:
    Type: 'AWS::EC2::NatGateway'
    DependsOn: PublicSubnet1
    Properties:
      AllocationId: !GetAtt 'EIP.AllocationId'
      SubnetId: !Ref PublicSubnet1

  NGWRoute:
    Type: 'AWS::EC2::Route'
    Properties:
      RouteTableId: !Ref PrivateRouteTable
      DestinationCidrBlock: '0.0.0.0/0'
      NatGatewayId: !Ref NatGateway
  
  EndpointRDS:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.rds'
      PrivateDnsEnabled: true
      SecurityGroupIds:
        - !Ref ClosedSG
      SubnetIds:
        # - !Ref PublicSubnet1
        # - !Ref PublicSubnet2
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      VpcEndpointType: Interface
      VpcId: !Ref VPC

  RDSProxyRole:
    Type: AWS::IAM::Role
    DependsOn:
      - DBCredentialsSecret
      - DBInstance
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - 'rds.amazonaws.com'
            Action:
              - 'sts:AssumeRole'
      Policies:
        - PolicyName: rdsproxypolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: 'secretsmanager:GetSecretValue'
                Resource: !Ref DBCredentialsSecret
              - Effect: Allow
                Action: rds-db:connect
                Resource: !Sub "arn:aws:rds:${AWS::Region}:${AWS::AccountId}:cluster:${DbCluster}"
              - Effect: Allow
                Action: rds-db:connect
                Resource: !Sub "arn:aws:rds:${AWS::Region}:${AWS::AccountId}:db:${DBInstance}"

  RDSProxy:
    Type: AWS::RDS::DBProxy
    DependsOn:
    - DBInstance
    - DBCredentialsSecret
    - PrivateSubnet1
    - PrivateSubnet2
    - RDSProxyRole
    Properties:
      DebugLogging: true
      DBProxyName: mcm-Rds-Proxy
      EngineFamily: MYSQL
      IdleClientTimeout: 120
      RequireTLS: false
      RoleArn: !GetAtt RDSProxyRole.Arn
      Auth:
        - {AuthScheme: SECRETS, SecretArn: !Ref DBCredentialsSecret, IAMAuth: DISABLED}
      VpcSubnetIds:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      VpcSecurityGroupIds:
        - !Ref ProxySG
      Tags:
        - Key: "Project"
          Value: !Ref 'ProjectName'
        - Key: "EnvironmentName"
          Value: !Ref 'EnvironmentName'

  RDSProxyTargetGroup:
    Type: AWS::RDS::DBProxyTargetGroup
    DependsOn:
    - DbCluster
    - RDSProxy
    Properties:
      DBProxyName: !Ref RDSProxy
      DBClusterIdentifiers: [!Ref DbCluster] 
      TargetGroupName: default
      ConnectionPoolConfigurationInfo:
          MaxConnectionsPercent: 100
          MaxIdleConnectionsPercent: 50
          ConnectionBorrowTimeout: 120


  # Lambda functions ####################################
  
  # graphQLMySQLResolverLayers:
  #   Type: AWS::Serverless::LayerVersion
  #   Properties:
  #     LayerName: graphQLMySQLResolverLayers
  #     Description: Dependency for Lambda
  #     ContentUri: ./lambda_functions/graphQLMySQLResolver/node_modules/

  graphQLMySQLResolver:
    Type: AWS::Serverless::Function
    DependsOn:
    - RDSProxy
    - ClosedSG
    - DBInstance
    # - LambdaServiceRole
    Properties:
      FunctionName: graphQL-MySQL-Resolver
      # Layers:
      #   - !Ref graphQLMySQLResolverLayers
      Handler: index.handler
      CodeUri: ./lambda_functions/graphQLMySQLResolver/
      Runtime: nodejs16.x
      Architectures:
        - x86_64
      MemorySize: 1000
      Timeout: 100
      ReservedConcurrentExecutions: 100
      Description: Called by AppSync to resolve SQL statements in the form of a request mapping and send requests to Pinpoint
      Role: !GetAtt GraphQLResolverRole.Arn
      Environment:
        Variables:
          DBNAME: !Ref 'DBName'
          # PASSWORD: !Ref 'DBPassword'
          # USERNAME: !Ref 'DBUser'
          RDSPROXY_ENDPOINT: !GetAtt RDSProxy.Endpoint
          EMAIL_SENDER: !Ref SenderEmail
          PINPOINT_APPID: !Ref PinpointApp
          LINK_TO_APP: !Ref LinkToHostingDomain
          ORGANIZATION_NAME: !Ref OrganizationName
      VpcConfig:
        SecurityGroupIds:
          - !Ref ClosedSG
        SubnetIds:
          - !Ref PrivateSubnet1
          - !Ref PrivateSubnet2
          
  graphQLMySQLResolverLogs:
    Type: AWS::Logs::LogGroup
    DependsOn: graphQLMySQLResolver
    Properties:
      LogGroupName: !Join ["", ["/aws/lambda/", !Ref graphQLMySQLResolver]]
      KmsKeyId: !GetAtt KmsKey.Arn
      RetentionInDays: 14


  # APPSYNC #####################################################

  AppSyncLogsRole:
    Type: AWS::IAM::Role
    Properties:
      ManagedPolicyArns:
        - "arn:aws:iam::aws:policy/service-role/AWSAppSyncPushToCloudWatchLogs"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - sts:AssumeRole
            Principal:
              Service:
                - appsync.amazonaws.com

  LambdaResolverAppSyncDataSource:
    Type: AWS::AppSync::DataSource
    DependsOn:
    - graphQLMySQLResolver
    # - GraphQLApiSchema
    # - GraphQLApiIdParameter
    Properties:
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      # ApiId: "{{resolve:ssm:GraphqlApiId:1}}"
      Name: LambdaHandler
      Type: AWS_LAMBDA
      ServiceRoleArn: !GetAtt LambdaServiceRole.Arn
      LambdaConfig:
        LambdaFunctionArn: !GetAtt graphQLMySQLResolver.Arn

  getUserByIdResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Query
      FieldName: getUserById
      RequestMappingTemplate: |
        {
          "version" : "2017-02-28",
          "operation": "Invoke",
          "payload": {
            "sql": "select `User`.* from `User` where `User`.user_id = :1;",
            "SQLVariableMapping": {
            ":1": $context.arguments.user_id
            }
          }
        }
        
      ResponseMappingTemplate: |
        #if($ctx.error) 
          $util.error($ctx.error.message, $ctx.error.type) 
        #end 
        $util.toJson($context.result.sqlResult[0])
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0

  getUserByEmailResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Query
      FieldName: getUserByEmail
      RequestMappingTemplate: |
        {
        "version" : "2017-02-28",
        "operation": "Invoke",
        "payload": {
        "sql": "select * from `User` where `User`.email_address = :1;",
        "SQLVariableMapping": {
        ":1": "$context.arguments.user_email"
        }
        }
        }
        
      ResponseMappingTemplate: |
        #if($ctx.error) 
          $util.error($ctx.error.message, $ctx.error.type) 
        #end 
        $util.toJson($context.result.sqlResult[0])
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0   
  
  getUserCategoryTopicByUserIdResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Query
      FieldName: getUserCategoryTopicByUserId
      RequestMappingTemplate: |
        {
        "version": "2018-05-29",
        "operation": "Invoke",
        "payload": {
        "sql": "select * from `UserCategoryTopic`, `CategoryTopic` where `UserCategoryTopic`.user_id = :1 and `UserCategoryTopic`.categoryTopic_id = `CategoryTopic`.categoryTopic_id;",
        "SQLVariableMapping": {
        ":1": $context.arguments.user_id
        }
        }
        }
        
      ResponseMappingTemplate: |
        #if($ctx.error) 
          $util.error($ctx.error.message, $ctx.error.type) 
        #end 
        $util.toJson($context.result.sqlResult)
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0   

  getCategoriesByUserIdResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Query
      FieldName: getCategoriesByUserId
      RequestMappingTemplate: |
        {
        "version": "2018-05-29",
        "operation": "Invoke",
        "payload": {
        "sql": "select c.category_id, ci.language, ci.title, ci.description, c.picture_location, uct.email_notice, uct.sms_notice from `Category` c, `CategoryInfo` ci, `UserCategoryTopic` uct, `CategoryTopic` ct where ci.category_id = ct.category_id and uct.user_id = :user_id and ct.category_id = c.category_id and ct.categoryTopic_id = uct.categoryTopic_id and ci.language=:language",
        "SQLVariableMapping": {
        ":user_id": $context.arguments.user_id,
        ":language": "$context.arguments.language"
        }
        }
        }
        
      ResponseMappingTemplate: |
        #if($ctx.error) 
          $util.error($ctx.error.message, $ctx.error.type) 
        #end 
        $util.toJson($context.result.sqlResult)
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0   

  getCategoryTopicByIdResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Query
      FieldName: getCategoryTopicById
      RequestMappingTemplate: |
        {
        "version": "2018-05-29",
        "operation": "Invoke",
        "payload": {
        "sql": "select * from `CategoryTopic` where categoryTopic_id = :id;",
        "SQLVariableMapping": {
        ":id": $context.arguments.categoryTopic_id
        }
        }
        }
        
      ResponseMappingTemplate: |
        #if($ctx.error) 
          $util.error($ctx.error.message, $ctx.error.type) 
        #end 
        $util.toJson($context.result.sqlResult[0])
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0   

  getCategoryResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Query
      FieldName: getCategory
      RequestMappingTemplate: |
        {
        "version": "2018-05-29",
        "operation": "Invoke",
        "payload": {
        "sql": "select * from CategoryInfo ci, Category c where c.category_id = :1 and ci.language = :2 and c.category_id = ci.category_id;",
        "SQLVariableMapping": {
        ":1": $context.arguments.category_id,
        ":2": "$context.arguments.language"
        }
        }
        }
        
      ResponseMappingTemplate: |
        #if($ctx.error) 
          $util.error($ctx.error.message, $ctx.error.type) 
        #end 
        $util.toJson($context.result.sqlResult[0])
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0   

  getTopicsOfCategoryResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Query
      FieldName: getTopicsOfCategory
      RequestMappingTemplate: |
        {
        "version": "2018-05-29",
        "operation": "Invoke",
        "payload": {
        "sql": "select t.topic_id, t.language, t.name from TopicInfo t, CategoryTopic ct where ct.category_id = :1 and t.topic_id = ct.topic_id and t.language = :2;",
        "SQLVariableMapping": {
        ":1": $context.arguments.category_id,
        ":2": "$context.arguments.language"
        }
        }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($context.result.sqlResult)
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0

  getTopicResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Query
      FieldName: getTopic
      RequestMappingTemplate: |
        {
        "version": "2018-05-29",
        "operation": "Invoke",
        "payload": {
        "sql": "select * from `TopicInfo` where `TopicInfo`.topic_id = :1 and `TopicInfo`.language = :2;",
        "SQLVariableMapping": {
        ":1": $context.arguments.topic_id,
        ":2": "$context.arguments.language"
        }
        }
        }

      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($context.result.sqlResult[0])
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0

  # getAllTopicsResolver:
  #   Type: AWS::AppSync::Resolver
  #   DependsOn:
  #   - LambdaResolverAppSyncDataSource
  #   Properties:
  #     TypeName: Query
  #     FieldName: getAllTopics
  #     RequestMappingTemplate: |
  #       {
  #       "version": "2018-05-29",
  #       "operation": "Invoke",
  #       "payload": {
  #       "sql": "select * from `Topic`",
  #       "SQLVariableMapping": {
  #       }
  #       }
  #       }

  #     ResponseMappingTemplate: |
  #       #if($ctx.error)
  #         $util.error($ctx.error.message, $ctx.error.type)
  #       #end
  #       $util.toJson($context.result.sqlResult)
  #     ApiId: !GetAtt GraphQLApiIdParameter.Value
  #     DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
  #     Kind: UNIT
  #     MaxBatchSize: 0

  getAllCategoriesForLanguageResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Query
      FieldName: getAllCategoriesForLanguage
      RequestMappingTemplate: |
        {
        "version": "2018-05-29",
        "operation": "Invoke",
        "payload": {
        "sql": "select * from `CategoryInfo`, `Category` where `CategoryInfo`.language=:1 and `Category`.category_id=`CategoryInfo`.category_id",
        "SQLVariableMapping": {
        ":1": "$context.arguments.language"
        }
        }
        }

      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($context.result.sqlResult)
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0
  
  getAllTopicsForLanguageResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Query
      FieldName: getAllTopicsForLanguage
      RequestMappingTemplate: |
        {
        "version": "2018-05-29",
        "operation": "Invoke",
        "payload": {
        "sql": "select * from `TopicInfo` where `TopicInfo`.language=:1",
        "SQLVariableMapping": {
        ":1": "$context.arguments.language"
        }
        }
        }

      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($context.result.sqlResult)
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0

  getAllCategoryTopicsResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Query
      FieldName: getAllCategoryTopics
      RequestMappingTemplate: |
        {
        "version": "2018-05-29",
        "operation": "Invoke",
        "payload": {
        "sql": "select * from `CategoryTopic`;",
        "SQLVariableMapping": {
        }
        }
        }

      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($context.result.sqlResult)
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0

  createUserResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Mutation
      FieldName: createUser
      RequestMappingTemplate: |
        #set($phone_address = $util.toJson($util.defaultIfNullOrEmpty($context.arguments.phone_address, null)))
        ## #set($phone_id = $util.toJson($util.defaultIfNullOrEmpty($context.arguments.phone_id, null)))
        #set($postal_code = $util.toJson($util.defaultIfNullOrEmpty($context.arguments.postal_code, null)))
        ## #if($context.arguments.phone_address)
        ##   #set( $phone_id = $user_id )
        ## #else 
        ##   #set( $phone_id = $util.toJson($util.defaultIfNullOrEmpty($context.arguments.phone_id, null)))
        ## #end
        #if($context.arguments.email_notice)
          #set( $email_notice = true )
        #else	
          #set( $email_notice = false )
        #end
        #if($context.arguments.sms_notice)
          #set( $sms_notice = true )
        #else	
          #set( $sms_notice = false )
        #end
        {
        "version": "2018-05-29",
        "operation": "Invoke",
        "payload": {
        "sql": "insert into `User` (email_address, phone_address, postal_code, province, email_notice, sms_notice, language) values (:email_address, :phone_address, :postal_code, :province, :email_notice, :sms_notice, :language);",
        "SQLVariableMapping": {
        ":email_address": "$context.arguments.email_address",
        ":phone_address": $phone_address,
        ## ":phone_id": $phone_id,
        ":postal_code": $postal_code,
        ":province": "$context.arguments.province",
        ":email_notice": $email_notice,
        ":sms_notice": $sms_notice,
        ":language": "$context.arguments.language"
        },
        "pinpoint":{"type": "userprofile", "action": "insert"},
        "responseSQL": "select * from `User` where email_address=:email_address"
        }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($context.result.sqlResult[0])
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      MaxBatchSize: 0
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT

  updateUserResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Mutation
      FieldName: updateUser
      RequestMappingTemplate: |
        #set($phone_address = $util.toJson($util.defaultIfNullOrEmpty($context.arguments.phone_address, null)))
        #set($email_address = $util.toJson($util.defaultIfNullOrEmpty($context.arguments.email_address, null)))
        #set($province = $util.toJson($util.defaultIfNullOrEmpty($context.arguments.province, null)))
        #set($postal_code = $util.toJson($util.defaultIfNullOrEmpty($context.arguments.postal_code, null)))

        #if($context.arguments.email_notice)
          #set( $sql_email_notice = "email_notice=true, " )
        #else	
          #set( $sql_email_notice = "email_notice=false, " )
        #end

        #if( $context.arguments.sms_notice )
          #if( $context.arguments.email_address || $context.arguments.phone_address || $context.arguments.province || $context.arguments.postal_code)
            #set( $sql_sms_notice = "sms_notice=true," )
          #else
            #set( $sql_sms_notice = "sms_notice=true" )
          #end        
        #else
          #if( $context.arguments.email_address || $context.arguments.phone_address || $context.arguments.province || $context.arguments.postal_code)
            #set( $sql_sms_notice = "sms_notice=false," )
          #else
            #set( $sql_sms_notice = "sms_notice=false" )
          #end  
        #end

        #if( $context.arguments.email_address )
          #if( $context.arguments.phone_address || $context.arguments.province || $context.arguments.postal_code)
            #set( $sql_email_address = "email_address=:email_address," )
          #else
            #set( $sql_email_address = "email_address=:email_address" )
          #end        
        #else
          #set( $sql_email_address = "" )
        #end
        #if( $context.arguments.phone_address )
          #if( $context.arguments.province || $context.arguments.postal_code)
            #set( $sql_phone_address = "phone_address=:phone_address," )
          #else
            #set( $sql_phone_address = "phone_address=:phone_address" )
          #end           
        #else
          #set( $sql_phone_address = "" )
        #end
        #if( $context.arguments.province )
          #if( $context.arguments.postal_code)
            #set( $sql_province = "province=:province," )
          #else
            #set( $sql_province = "province=:province" )
          #end          
        #else
          #set( $sql_province = "" )
        #end
        #if( $context.arguments.postal_code )
          #set( $sql_postal_code = "postal_code=:postal_code" )
        #else
          #set( $sql_postal_code = "" )
        #end
        {
        "version": "2018-05-29",
        "operation": "Invoke",
        "payload": {
        "sql": "UPDATE `User` SET $sql_email_notice $sql_sms_notice $sql_email_address $sql_phone_address $sql_province $sql_postal_code WHERE `User`.user_id = :user_id;",
        "SQLVariableMapping": {
        ":user_id": $context.arguments.user_id,
        ":email_address": $email_address,
        ":phone_address": $phone_address,
        ":province": $province,
        ":postal_code": $postal_code
        },
        "pinpoint":{"type": "userprofile", "action": "update"},
        "responseSQL": "select * from `User` where user_id=:user_id;"
        }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($context.result.sqlResult[0])
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0

  deleteUserResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Mutation
      FieldName: deleteUser
      RequestMappingTemplate: |
         {
          "version": "2018-05-29",
          "operation": "Invoke",
          "payload": {
            "sql": "DELETE FROM `User` WHERE user_id = :user_id;",
            "SQLVariableMapping": {
                ":user_id": $context.arguments.user_id
            },
          "pinpoint":{"type": "userprofile", "action": "delete"}
          }
          }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        "Succeeded"
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0

  createCategoryResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Mutation
      FieldName: createCategory
      RequestMappingTemplate: |
        #set($picture_location = $util.toJson($util.defaultIfNullOrEmpty("$context.arguments.picture_location", null)))
        #set($description = $util.toJson($util.defaultIfNullOrEmpty("$context.arguments.english_description", null)))
        {
        "version": "2018-05-29",
        "operation": "Invoke",
        "payload": {
        "sql": "insert into Category (picture_location) values (:picture_location); SET @last_id_in_table1 = LAST_INSERT_ID(); INSERT INTO CategoryInfo (category_id,language,title,description) VALUES (@last_id_in_table1, 'en', :title, :description); ",
        "SQLVariableMapping": {
        ":picture_location": $picture_location,
        ":title": "$context.arguments.english_title",
        ":description": $description
        },
        "responseSQL": "select * from `CategoryInfo` where title=:title;"
        }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($context.result.sqlResult[0])
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0


  addCategoryDisplayLanguageResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Mutation
      FieldName: addCategoryDisplayLanguage
      RequestMappingTemplate: |
        #set($description = $util.toJson($util.defaultIfNullOrEmpty($context.arguments.description, null)))
        #set($description_fr = $util.toJson($util.defaultIfNullOrEmpty($context.arguments.description_fr, null)))
        {
        "version": "2018-05-29",
        "operation": "Invoke",
        "payload": {
        "sql": "insert into `CategoryInfo` (category_id, language, title, description) values (:id, :language, :title, :description);",
        "SQLVariableMapping": {
        ":id": $context.arguments.category_id,
        ":language": "$context.arguments.language",
        ":title": "$context.arguments.title",
        ":description": $description
        },
        "responseSQL": "select * from `CategoryInfo` where category_id=:id;"
        }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($context.result.sqlResult[0])
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0

  UpdateCategoryResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Mutation
      FieldName: updateCategory
      RequestMappingTemplate: |
        #if( $context.arguments.picture_location )
          #set( $picture_location = "picture_location=:picture_location" )
        #else
          #set( $picture_location = "" )
        #end

        {
        "version": "2018-05-29",
        "operation": "Invoke",
        "payload": {
        "sql": "UPDATE `Category` SET $picture_location WHERE `Category`.category_id = :category_id;",
        "SQLVariableMapping": {
        ":category_id": $context.arguments.category_id,
        ":picture_location": "$context.arguments.picture_location",
        },
        "responseSQL": "select * from `Category` where category_id=:category_id;"
        }
        }

      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($context.result.sqlResult[0])
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0

  updateCategoryInfoResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Mutation
      FieldName: updateCategoryInfo
      RequestMappingTemplate: |
        #if( $context.arguments.title )
          #if( $context.arguments.description)
            #set( $title = "title=:title," )
          #else
            #set( $title = "title=:title" )
          #end
        #else
          #set( $title = "" )
        #end
        #if( $context.arguments.description )
          #set( $description = "description=:description" )
        #else
          #set( $description = "" )
        #end

        {
        "version": "2018-05-29",
        "operation": "Invoke",
        "payload": {
        "sql": "UPDATE `CategoryInfo` SET $title $description WHERE `CategoryInfo`.category_id = :category_id and `CategoryInfo`.language = :language;",
        "SQLVariableMapping": {
        ":category_id": $context.arguments.category_id,
        ":language": "$context.arguments.language",
        ":title": "$context.arguments.title",
        ":description": "$context.arguments.description",
        },
        "responseSQL": "select * from `CategoryInfo` where category_id=:category_id;"
        }
        }

      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($context.result.sqlResult[0])
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0


  deleteCategoryResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Mutation
      FieldName: deleteCategory
      RequestMappingTemplate: |
        {
        "version": "2018-05-29",
        "operation": "Invoke",
        "payload": {
        "sql": "delete from `Category` where category_id=:category_id;",
        "SQLVariableMapping": {
          ":category_id": $context.arguments.category_id
        }
        }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        "'delete succeeded'"
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0

  createTopicResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Mutation
      FieldName: createTopic
      RequestMappingTemplate: |
        {
        "version": "2018-05-29",
        "operation": "Invoke",
        "payload": {
        "sql": "INSERT INTO Topic () VALUES (); SET @last_id_in_table1 = LAST_INSERT_ID(); INSERT INTO TopicInfo (topic_id,language,name) VALUES (@last_id_in_table1, 'en', :name); ",
        "SQLVariableMapping": {
        ":name": "$context.arguments.english_name"
        },
        "responseSQL": "select * from `TopicInfo` where name=:name and language='en';"
        }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($context.result.sqlResult[0])
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0

  addTopicDisplayLanguageResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Mutation
      FieldName: addTopicDisplayLanguage
      RequestMappingTemplate: |
        {
        "version": "2018-05-29",
        "operation": "Invoke",
        "payload": {
        "sql": "insert into `TopicInfo` (topic_id, language, name) values (:id, :language, :name);",
        "SQLVariableMapping": {
        ":id": $context.arguments.topic_id,
        ":language": "$context.arguments.language",
        ":name": "$context.arguments.name"
        },
        "responseSQL": "select * from `TopicInfo` where topic_id=:id and language=:language;"
        }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($context.result.sqlResult[0])
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0

  # updateTopicResolver:
  #   Type: AWS::AppSync::Resolver
  #   DependsOn:
  #   - LambdaResolverAppSyncDataSource
  #   Properties:
  #     TypeName: Mutation
  #     FieldName: updateTopic
  #     RequestMappingTemplate: |
  #       {
  #       "version": "2018-05-29",
  #       "operation": "Invoke",
  #       "payload": {
  #       "sql": "insert into `Topic` (language, name) values (:language, :name);",
  #       "SQLVariableMapping": {
  #       ":language": "$context.arguments.language",
  #       ":name": "$context.arguments.name"
  #       },
  #       "responseSQL": "select * from `Topic` where name=:name;"
  #       }
  #       }
  #     ResponseMappingTemplate: |
  #       #if($ctx.error)
  #         $util.error($ctx.error.message, $ctx.error.type)
  #       #end
  #       $util.toJson($context.result.sqlResult[0])
  #     ApiId: !GetAtt GraphQLApiIdParameter.Value
  #     DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
  #     Kind: UNIT
  #     MaxBatchSize: 0


  deleteTopicResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Mutation
      FieldName: deleteTopic
      RequestMappingTemplate: |
        {
        "version": "2018-05-29",
        "operation": "Invoke",
        "payload": {
        "sql": "delete from `Topic` where topic_id=:topic_id;",
        "SQLVariableMapping": {
        ":topic_id": $context.arguments.topic_id
        }
        }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        "Delete succeeded"
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0

  addTopicToCategoryResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Mutation
      FieldName: addTopicToCategory
      RequestMappingTemplate: |
        {
        "version": "2018-05-29",
        "operation": "Invoke",
        "payload": {
        "sql": "insert into `CategoryTopic` (category_id, topic_id) values (:category_id, :topic_id);",
        "SQLVariableMapping": {
        ":category_id": $context.arguments.category_id,
        ":topic_id": $context.arguments.topic_id
        },
        "responseSQL": "select * from `CategoryTopic` where category_id=:category_id and topic_id=:topic_id;"
        }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($context.result.sqlResult[0])
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0

  deleteCategoryTopicResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Mutation
      FieldName: deleteCategoryTopic
      RequestMappingTemplate: |
        {
        "version": "2018-05-29",
        "operation": "Invoke",
        "payload": {
        "sql": "delete from `CategoryTopic` where category_id=:category_id and topic_id=:topic_id;",
        "SQLVariableMapping": {
        ":category_id": $context.arguments.category_id,
        ":topic_id": $context.arguments.topic_id
        }
        }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($context.result.sqlResult[0])
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0

  userFollowCategoryTopicResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Mutation
      FieldName: userFollowCategoryTopic
      RequestMappingTemplate: |
        #if($context.arguments.email_notice)
          #set( $email_notice = true )
        #else	
          #set( $email_notice = false )
        #end
        #if($context.arguments.sms_notice)
          #set( $sms_notice = true )
        #else	
          #set( $sms_notice = false )
        #end
        ## "insert into `UserCategoryTopic` (user_id, email_notice, sms_notice, categoryTopic_id) select :user_id, :email_notice, :sms_notice, `CategoryTopic`.categoryTopic_id from `CategoryTopic`, `UserCategoryTopic` where `CategoryTopic`.category_id = :category_id and `CategoryTopic`.topic_id = :topic_id;",
        {
        "version": "2018-05-29",
        "operation": "Invoke",
        "payload": {
        "sql": 
          "insert into `UserCategoryTopic` (user_id, email_notice, sms_notice, categoryTopic_id) select :user_id, :email_notice, :sms_notice, `CategoryTopic`.categoryTopic_id from `CategoryTopic` where `CategoryTopic`.category_id = :category_id and `CategoryTopic`.topic_id = :topic_id;",
        "SQLVariableMapping": {
        ":user_id": $context.arguments.user_id,
        ":email_notice": $email_notice,
        ":sms_notice": $sms_notice,
        ":category_id": $context.arguments.category_id,
        ":topic_id": $context.arguments.topic_id
        },
        "pinpoint": {"type": "usersubscription", "action": "insert"},
        "responseSQL": "select * from `CategoryInfo` c, `TopicInfo` t, `UserCategoryTopic` uct where uct.user_id = :user_id and c.category_id = :category_id and t.topic_id = :topic_id and c.language='en' and t.language='en';"
        }
        }

      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($context.result.sqlResult[0])
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0

  userUpdateChannelPrefrenceResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Mutation
      FieldName: userUpdateChannelPrefrence
      RequestMappingTemplate: |
        #if($context.arguments.email_notice)
          #set( $email_notice = true )
        #else	
          #set( $email_notice = false )
        #end
        #if($context.arguments.sms_notice)
          #set( $sms_notice = true )
        #else	
          #set( $sms_notice = false )
        #end
        ## "update table `UserCategoryTopic` (user_id, email_notice, sms_notice, categoryTopic_id) select :user_id, :email_notice, :sms_notice, `CategoryTopic`.categoryTopic_id from `CategoryTopic`, `UserCategoryTopic` where `CategoryTopic`.category_id = :category_id and `CategoryTopic`.topic_id = :topic_id;",
        {
        "version": "2018-05-29",
        "operation": "Invoke",
        "payload": {
        "sql":
          "update `UserCategoryTopic`, `CategoryTopic` set `UserCategoryTopic`.email_notice = :email_notice, `UserCategoryTopic`.sms_notice = :sms_notice where `UserCategoryTopic`.user_id = :user_id and `CategoryTopic`.category_id = :category_id and `CategoryTopic`.topic_id = :topic_id and `UserCategoryTopic`.categoryTopic_id = `CategoryTopic`.categoryTopic_id;",
          ##"update `UserCategoryTopic` set email_notice=:email_notice, sms_notice=:sms_notice from (select categoryTopic_id from `CategoryTopic`) as CategoryTopic where `CategoryTopic`.category_id = :category_id and `CategoryTopic`.topic_id = :topic_id and `UserCategoryTopic`.categoryTopic_id=`CategoryTopic`.categoryTopic_id;",
          ##"insert into `UserCategoryTopic` (user_id, email_notice, sms_notice, categoryTopic_id) select :user_id, :email_notice, :sms_notice, `CategoryTopic`.categoryTopic_id from `CategoryTopic` where `CategoryTopic`.category_id = :category_id and `CategoryTopic`.topic_id = :topic_id;",
        "SQLVariableMapping": {
        ":user_id": $context.arguments.user_id,
        ":email_notice": $email_notice,
        ":sms_notice": $sms_notice,
        ":category_id": $context.arguments.category_id,
        ":topic_id": $context.arguments.topic_id
        },
        "pinpoint": {"type": "usersubscription", "action": "update"},
        "responseSQL": "select * from `CategoryInfo` c, `TopicInfo` t, `UserCategoryTopic` uct where uct.user_id = :user_id and c.category_id = :category_id and t.topic_id = :topic_id and c.language='en' and t.language='en';"
        }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($context.result.sqlResult[0])
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0

  userUnfollowCategoryTopicResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Mutation
      FieldName: userUnfollowCategoryTopic
      RequestMappingTemplate: |
        {
        "version": "2018-05-29",
        "operation": "Invoke",
        "payload": {
        "sql": 
          "delete from `UserCategoryTopic` where `UserCategoryTopic`.user_id = :user_id and `UserCategoryTopic`.categoryTopic_id in (select categoryTopic_id from `CategoryTopic` where `CategoryTopic`.category_id = :category_id and `CategoryTopic`.topic_id = :topic_id);",
        "SQLVariableMapping": {
        ":user_id": $context.arguments.user_id,
        ":category_id": $context.arguments.category_id,
        ":topic_id": $context.arguments.topic_id
        },
        "pinpoint": {"type": "usersubscription", "action": "delete"},
        "responseSQL": "select * from `CategoryInfo` c, `TopicInfo` t where c.category_id = :category_id and t.topic_id = :topic_id and c.language='en' and t.language='en';"
        }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($context.result.sqlResult[0])
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0

  # userUnfollowCategoryResolver:
  #   Type: AWS::AppSync::Resolver
  #   DependsOn:
  #   - LambdaResolverAppSyncDataSource
  #   Properties:
  #     TypeName: Mutation
  #     FieldName: userUnfollowCategory
  #     RequestMappingTemplate: |
  #       {
  #       "version": "2018-05-29",
  #       "operation": "Invoke",
  #       "payload": {
  #       "sql": 
  #         "delete from `UserCategoryTopic` where `UserCategoryTopic`.user_id = :user_id and `UserCategoryTopic`.categoryTopic_id in (select categoryTopic_id from `CategoryTopic` where `CategoryTopic`.category_id = :category_id);",
  #       "SQLVariableMapping": {
  #       ":user_id": $context.arguments.user_id,
  #       ":category_id": $context.arguments.category_id,
  #       },
  #       "pinpoint": {"type": "usersubscription", "action": "delete"},
  #       "responseSQL": "select * from `CategoryInfo` c, `TopicInfo` t, `UserCategoryTopic` uct where uct.user_id = :user_id and c.category_id = :category_id and t.topic_id = :topic_id and c.language='en' and t.language='en';"
  #       }
  #       }
  #     ResponseMappingTemplate: |
  #       #if($ctx.error)
  #         $util.error($ctx.error.message, $ctx.error.type)
  #       #end
  #       "success"
  #     ApiId: !GetAtt GraphQLApiIdParameter.Value
  #     DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
  #     Kind: UNIT
  #     MaxBatchSize: 0

  testSQLResolver:
    Type: AWS::AppSync::Resolver
    DependsOn:
    - LambdaResolverAppSyncDataSource
    Properties:
      TypeName: Query
      FieldName: testSQL
      RequestMappingTemplate: |
        {
        "version": "2018-05-29",
        "operation": "Invoke",
        "payload": {
        "sql": 
          "alter table Category add column title_fr VARCHAR(50) NOT NULL;",
        "SQLVariableMapping": {}
        }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        "success"
      ApiId: !GetAtt GraphQLApiIdParameter.Value
      DataSourceName: !GetAtt LambdaResolverAppSyncDataSource.Name
      Kind: UNIT
      MaxBatchSize: 0

  # SES
  AdminSESIdentity:
    Type: AWS::SES::EmailIdentity
    Properties:
      EmailIdentity: !Ref SenderEmail
  # Pinpoint Resources
  PinpointApp:
    Type: AWS::Pinpoint::App
    Properties:
      Name: PinpointApp
  PinpointSMSChannel:
    Type: AWS::Pinpoint::SMSChannel
    DependsOn: 
    - PinpointApp
    Properties:
      ApplicationId: !Ref PinpointApp
      Enabled: true
  PinpointEmailChannel:
    Type: AWS::Pinpoint::EmailChannel
    DependsOn: 
    - AdminSESIdentity
    - PinpointApp
    Properties:
      ApplicationId: !Ref PinpointApp
      FromAddress: !Ref SenderEmail
      Identity: 
        !Sub 'arn:aws:ses:${AWS::Region}:${AWS::AccountId}:identity/${SenderEmail}'
      Enabled: true
  EmailSenderParameter:
      Type: AWS::SSM::Parameter
      Properties: 
        Name: "EmailSenderParameter"
        Type: String 
        Value: !Ref SenderEmail
        Description: sender email for all SES communications


  #Lambda Resources
  GraphQLResolverRole:
    Type: AWS::IAM::Role
    Properties:
      # RoleName: GraphQLResolverRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
            - pinpoint.amazonaws.com
          Action:
            - 'sts:AssumeRole'
      Policies:
      - PolicyName: lambda-resolver-policy
        PolicyDocument:
          Version: "2012-10-17"
          Statement:
          - Effect: Allow
            Action: logs:CreateLogGroup
            Resource: 
            - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*'
          - Effect: Allow
            Action:
            - logs:CreateLogStream
            - logs:PutLogEvents
            Resource: 
            - !Sub arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/GraphQL-MySQL-Resolver:*
          - Effect: Allow
            Action:
            - mobiletargeting:Create*
            - mobiletargeting:Delete*
            - mobiletargeting:Get*
            - mobiletargeting:Send*
            - mobiletargeting:Update*
            - mobiletargeting:List*
            # Resource: '*'
            Resource: 
            - !GetAtt PinpointApp.Arn
            - !Sub "arn:aws:mobiletargeting:${AWS::Region}:${AWS::AccountId}:apps/*/endpoints/*"
          - Effect: Allow
            Action: rds-db:connect
            Resource: 
            - !GetAtt RDSProxy.DBProxyArn
          - Effect: Allow
            Action:
            - "ec2:CreateNetworkInterface"
            - "ec2:DeleteNetworkInterface"
            - "ec2:DescribeNetworkInterfaces"
            Resource: '*'
          # - Effect: Allow
          #   Action:
          #   - "ses:SendEmail"
          #   Resource: 'arn:aws:ses:${AWS::Region}:${AWS::AccountId}:identity:*'
      Description: Role for graphql resolver lambda
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      - arn:aws:iam::aws:policy/IAMReadOnlyAccess
      - arn:aws:iam::aws:policy/SecretsManagerReadWrite
      - arn:aws:iam::aws:policy/AmazonRDSFullAccess
      - arn:aws:iam::aws:policy/AWSAppSyncInvokeFullAccess
      - arn:aws:iam::aws:policy/AmazonSESFullAccess
  
  WAF:
    Type: AWS::WAFv2::WebACL
    Properties:
      Name: mcmWAF
      Scope: REGIONAL
      DefaultAction:
        Allow: {}
      VisibilityConfig:
        SampledRequestsEnabled: true
        CloudWatchMetricsEnabled: true
        MetricName: mcm-waf
      Rules:
        - Name: AWS-AWSManagedRulesCommonRuleSet
          Priority: 1
          Statement:
            ManagedRuleGroupStatement:
              VendorName: AWS
              Name: AWSManagedRulesCommonRuleSet
          OverrideAction:
            None: {}
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: AWS-AWSManagedRulesCommonRuleSet
        - Name: LimitRequests1000
          Priority: 2
          Action:
            Block: {}
          Statement:
            RateBasedStatement:
              Limit: 1000
              AggregateKeyType: IP
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: LimitRequests1000

  WAFAssociation:
    Type: AWS::WAFv2::WebACLAssociation
    Properties:
      ResourceArn: !Sub "arn:aws:appsync:${AWS::Region}:${AWS::AccountId}:apis/${GraphQLApiIdParameter.Value}"
      WebACLArn: !GetAtt WAF.Arn

  KmsKey:
    Type: AWS::KMS::Key
    Properties: 
      Description: KMS key for root user in the account to access sms secrets and cloudwatch logs
      EnableKeyRotation: true
      KeyPolicy: 
        Version: 2012-10-17
        Id: key-mcm-1
        Statement:
          - Sid: Enable IAM User Permissions
            Effect: Allow
            Principal:
              AWS: !Sub "arn:aws:iam::${AWS::AccountId}:root"
            Action: 'kms:*'
            Resource: '*'
          - Effect: Allow
            Principal:
              Service: !Sub "logs.${AWS::Region}.amazonaws.com"
            Action: 
              - "kms:Encrypt*"
              - "kms:Decrypt*"
              - "kms:ReEncrypt*"
              - "kms:GenerateDataKey*"
              - "kms:Describe*"
            Resource: '*'
          - Effect: Allow
            Principal:
              Service: !Sub "secretsmanager.${AWS::Region}.amazonaws.com"
            Action: 
              - "kms:Encrypt*"
              - "kms:Decrypt*"
              - "kms:ReEncrypt*"
              - "kms:GenerateDataKey*"
              - "kms:Describe*"
            Resource: '*'
      Tags:
        - Key: "Project"
          Value: !Ref 'ProjectName'
        - Key: "EnvironmentName"
          Value: !Ref 'EnvironmentName'